from datetime import datetime, timedelta
from typing import Optional, Dict, Any
import json
import uuid

class CalendarIntegration:
    """
    Calendar integration service for scheduling interviews
    Supports Google Calendar, Outlook, and iCal formats
    """
    
    def __init__(self):
        self.calendar_providers = ["google", "outlook", "ical"]
    
    def generate_ical_event(self, 
                           title: str,
                           start_time: datetime,
                           end_time: datetime,
                           description: str = "",
                           location: str = "",
                           attendees: list = None) -> str:
        """Generate iCal format event"""
        
        attendees = attendees or []
        uid = str(uuid.uuid4())
        
        ical_content = f"""BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//HireOps//Interview Scheduler//EN
CALSCALE:GREGORIAN
METHOD:REQUEST
BEGIN:VEVENT
DTSTART:{start_time.strftime('%Y%m%dT%H%M%SZ')}
DTEND:{end_time.strftime('%Y%m%dT%H%M%SZ')}
DTSTAMP:{datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}
UID:{uid}
SUMMARY:{title}
DESCRIPTION:{description}
LOCATION:{location}
STATUS:CONFIRMED
SEQUENCE:0
TRANSP:OPAQUE"""

        for attendee in attendees:
            ical_content += f"\nATTENDEE:MAILTO:{attendee}"
        
        ical_content += "\nEND:VEVENT\nEND:VCALENDAR"
        
        return ical_content
    
    def generate_google_calendar_url(self,
                                   title: str,
                                   start_time: datetime,
                                   end_time: datetime,
                                   description: str = "",
                                   location: str = "") -> str:
        """Generate Google Calendar add event URL"""
        
        base_url = "https://calendar.google.com/calendar/render"
        
        params = {
            "action": "TEMPLATE",
            "text": title,
            "dates": f"{start_time.strftime('%Y%m%dT%H%M%SZ')}/{end_time.strftime('%Y%m%dT%H%M%SZ')}",
            "details": description,
            "location": location
        }
        
        query_string = "&".join([f"{k}={v}" for k, v in params.items() if v])
        return f"{base_url}?{query_string}"
    
    def generate_outlook_calendar_url(self,
                                    title: str,
                                    start_time: datetime,
                                    end_time: datetime,
                                    description: str = "",
                                    location: str = "") -> str:
        """Generate Outlook Calendar add event URL"""
        
        base_url = "https://outlook.live.com/calendar/0/deeplink/compose"
        
        params = {
            "subject": title,
            "startdt": start_time.isoformat(),
            "enddt": end_time.isoformat(),
            "body": description,
            "location": location
        }
        
        query_string = "&".join([f"{k}={v}" for k, v in params.items() if v])
        return f"{base_url}?{query_string}"
    
    def create_interview_calendar_event(self,
                                      candidate_name: str,
                                      job_title: str,
                                      interview_type: str,
                                      start_time: datetime,
                                      duration_minutes: int = 60,
                                      interviewer: str = "",
                                      location: str = "",
                                      attendees: list = None) -> Dict[str, Any]:
        """Create calendar event for interview"""
        
        end_time = start_time + timedelta(minutes=duration_minutes)
        
        title = f"Interview: {candidate_name} - {job_title}"
        description = f"""
Interview Details:
- Candidate: {candidate_name}
- Position: {job_title}
- Interview Type: {interview_type}
- Interviewer: {interviewer}
- Duration: {duration_minutes} minutes

Please join the interview at the scheduled time.

Generated by HireOps Recruitment System
        """.strip()
        
        # Generate different calendar formats
        ical_content = self.generate_ical_event(
            title, start_time, end_time, description, location, attendees
        )
        
        google_url = self.generate_google_calendar_url(
            title, start_time, end_time, description, location
        )
        
        outlook_url = self.generate_outlook_calendar_url(
            title, start_time, end_time, description, location
        )
        
        return {
            "event_details": {
                "title": title,
                "start_time": start_time.isoformat(),
                "end_time": end_time.isoformat(),
                "duration_minutes": duration_minutes,
                "description": description,
                "location": location,
                "attendees": attendees or []
            },
            "calendar_links": {
                "google": google_url,
                "outlook": outlook_url,
                "ical_download": "/api/calendar/download-ical"  # Would serve the iCal file
            },
            "ical_content": ical_content
        }
    
    def generate_availability_slots(self,
                                  start_date: datetime,
                                  end_date: datetime,
                                  working_hours: Dict[str, Any] = None) -> list:
        """Generate available time slots for interview scheduling"""
        
        # Default working hours: 9 AM to 5 PM, Monday to Friday
        if not working_hours:
            working_hours = {
                "start_hour": 9,
                "end_hour": 17,
                "working_days": [0, 1, 2, 3, 4],  # Monday to Friday
                "slot_duration": 60  # minutes
            }
        
        slots = []
        current_date = start_date.replace(hour=0, minute=0, second=0, microsecond=0)
        
        while current_date <= end_date:
            # Check if it's a working day
            if current_date.weekday() in working_hours["working_days"]:
                # Generate slots for the day
                slot_start = current_date.replace(hour=working_hours["start_hour"])
                day_end = current_date.replace(hour=working_hours["end_hour"])
                
                while slot_start < day_end:
                    slot_end = slot_start + timedelta(minutes=working_hours["slot_duration"])
                    
                    if slot_end <= day_end:
                        slots.append({
                            "start": slot_start.isoformat(),
                            "end": slot_end.isoformat(),
                            "available": True,  # Would check against existing bookings
                            "day": slot_start.strftime("%A"),
                            "time": slot_start.strftime("%I:%M %p")
                        })
                    
                    slot_start = slot_end
            
            current_date += timedelta(days=1)
        
        return slots
    
    def check_time_conflicts(self,
                           proposed_start: datetime,
                           proposed_end: datetime,
                           existing_events: list) -> Dict[str, Any]:
        """Check for scheduling conflicts"""
        
        conflicts = []
        
        for event in existing_events:
            event_start = datetime.fromisoformat(event.get("start", ""))
            event_end = datetime.fromisoformat(event.get("end", ""))
            
            # Check for overlap
            if (proposed_start < event_end and proposed_end > event_start):
                conflicts.append({
                    "event_title": event.get("title", "Unknown Event"),
                    "event_start": event_start.isoformat(),
                    "event_end": event_end.isoformat(),
                    "overlap_minutes": min(proposed_end, event_end) - max(proposed_start, event_start)
                })
        
        return {
            "has_conflicts": len(conflicts) > 0,
            "conflict_count": len(conflicts),
            "conflicts": conflicts,
            "suggested_alternatives": self._suggest_alternatives(proposed_start, proposed_end, existing_events)
        }
    
    def _suggest_alternatives(self,
                            original_start: datetime,
                            original_end: datetime,
                            existing_events: list) -> list:
        """Suggest alternative time slots"""
        
        duration = original_end - original_start
        alternatives = []
        
        # Suggest 3 alternatives: 1 hour before, 1 hour after, next day same time
        suggestions = [
            original_start - timedelta(hours=1),
            original_start + timedelta(hours=1),
            original_start + timedelta(days=1)
        ]
        
        for suggested_start in suggestions:
            suggested_end = suggested_start + duration
            
            # Check if this alternative has conflicts
            has_conflict = any(
                suggested_start < datetime.fromisoformat(event.get("end", "")) and
                suggested_end > datetime.fromisoformat(event.get("start", ""))
                for event in existing_events
            )
            
            if not has_conflict:
                alternatives.append({
                    "start": suggested_start.isoformat(),
                    "end": suggested_end.isoformat(),
                    "day": suggested_start.strftime("%A, %B %d"),
                    "time": f"{suggested_start.strftime('%I:%M %p')} - {suggested_end.strftime('%I:%M %p')}"
                })
        
        return alternatives[:3]  # Return top 3 alternatives

# Create global calendar service instance
calendar_service = CalendarIntegration()